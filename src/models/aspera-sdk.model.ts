import {CustomBrandingOptions, DataTransferResponse, AsperaSdkSpec, AsperaSdkTransfer, FileDialogOptions, FolderDialogOptions, InitOptions, InstallerInfoResponse, InstallerOptions, ModifyTransferOptions, Pagination, PaginatedFilesResponse, ResumeTransferOptions, SafariExtensionEvent, TransferSpec, WebsocketEvent, InstallerUrlInfo, RpcMethod, SdkCapabilities} from './models';
import {hiddenStyleList, installerUrl, protocol} from '../constants/constants';
import {messages} from '../constants/messages';
import {safariClient} from '../helpers/client/safari-client';
import {client} from '../helpers/client/client';
import {errorLog, isSafari} from '../helpers/helpers';
import {websocketService} from '../helpers/ws';
import {asperaSdk} from '../index';
import {HttpGatewayInfo} from '../http-gateway/models';
import * as ConnectTypes from '@ibm-aspera/connect-sdk-js/dist/esm/core/types';
import {Connect, ConnectInstaller} from '@ibm-aspera/connect-sdk-js';

export class AsperaSdkGlobals {
  /** The URL of the IBM Aspera HTTP server to use with the SDK */
  asperaAppUrl = 'http://127.0.0.1';
  /** The URL of the IBM Aspera Desktop HTTP server to use with the SDK */
  rpcPort = 33024;
  /** The list of RPC methods supported by the running IBM Aspera for desktop application */
  rpcMethods: string[] = [];
  /** The default URL to check for latest Aspera installers */
  installerUrl = installerUrl;
  /** Aspera SDK info */
  asperaSdkInfo: AsperaSdkClientInfo;
  /** Indicate that the server has been verified as working */
  asperaAppVerified = false;
  /** The unique ID for the website */
  appId: string;
  /** Indicate if multiple session is supported */
  supportMultipleUsers = false;
  /** The session ID for the current user */
  sessionId?: string;
  /** Map of drop zones created by querySelector */
  dropZonesCreated: Map<string, {event: string; callback: (event: any) => void}[]> = new Map();
  /** HTTP Gateway URL after successful passing */
  httpGatewayUrl?: string;
  /** Indicate that the HTTP Gateway has been verified as working */
  httpGatewayVerified = false;
  /** HTTP Gateway info */
  httpGatewayInfo?: HttpGatewayInfo;
  /** Http Gateway IFRAME container */
  httpGatewayIframeContainer?: HTMLDivElement;
  /** Connect raw AW4 objects */
  connectAW4?: {
    Connect: typeof Connect,
    ConnectInstaller: typeof ConnectInstaller,
  };
  /** Connect instance */
  connect?: ConnectTypes.ConnectClientType;
  /** Connect installer instance */
  connectInstaller?: ConnectTypes.ConnectInstallerClientType;
  /** Connect status */
  connectStatus: ConnectTypes.ConnectStatusStrings = 'WAITING';

  backupLaunchMethod(url: string): void {
    window.alert(messages.loadingProtocol);
    window.location.href = url;
  }

  /**
   * Launch the IBM Aspera App via protocol url. By default, a hidden IFRAME attempts to
   * open the app but if that fails a fallback of opening a new window happens.
   */
  launch(): void {
    try {
      const element = document.createElement('iframe');
      element.src = protocol;
      element.onerror = error => {
        errorLog(messages.failedToGenerateIframe, error);
        this.backupLaunchMethod(protocol);
      };
      element.setAttribute('style', hiddenStyleList);
      document.body.appendChild(element);
    } catch (error) {
      errorLog(messages.failedToGenerateIframe, error);
      this.backupLaunchMethod(protocol);
    }
  }

  get sdkResponseData(): AsperaSdkInfo {
    return {
      verified: this.asperaAppVerified,
      ...this.asperaSdkInfo,
      httpGateway: {
        verified: this.httpGatewayVerified,
        url: this.httpGatewayUrl,
        info: this.httpGatewayInfo,
      },
      connect: {
        active: this.connectStatus === 'RUNNING',
        status: this.connectStatus,
      },
    };
  }
}

export interface AsperaSdkClientInfo {
  /** The version of IBM Aspera SDK */
  version: string;
  /** The public key corresponding to the SSH private key generated by IBM Aspera */
  client_pubkey?: string;
}

export type AsperaSdkInfo = AsperaSdkClientInfo&{
  verified: boolean;
  httpGateway: {
    verified: boolean;
    url?: string;
    info?: HttpGatewayInfo;
  };
  connect: {
    active: boolean;
    status: ConnectTypes.ConnectStatusStrings;
  }
}

export interface TransferResponse {
  transfers: AsperaSdkTransfer[];
}

export type ActivityMessageTypes = 'transferUpdated'|'transferRemoved';

export interface ActivityMessage {
  type: ActivityMessageTypes;
  data: unknown;
}

export class ActivityTracking {
  /** Map of callbacks that receive transfer update events */
  private activity_callbacks: Map<string, Function> = new Map();
  /** Map of callbacks that receive connection events */
  private event_callbacks: Map<string, Function> = new Map();
  /** Keep track of the last WebSocket event **/
  private lastWebSocketEvent: WebsocketEvent = 'CLOSED';
  /** Keep track of the last notified WebSocket event **/
  private lastNotifiedWebSocketEvent: WebsocketEvent = undefined;

  /**
   * Notify all consumers when a message is received from the transfer client.
   *
   * @param message the message received
   */
  handleTransferActivity(message: ActivityMessage): void {
    const data = message.data && typeof message.data === 'object' && 'transfers' in message.data
      ? message.data
      : {transfers: [message.data]};

    if (message.type === 'transferUpdated' || message.type === 'transferRemoved') {
      this.activity_callbacks.forEach(callback => {
        if (typeof callback === 'function') {
          callback(data);
        }
      });
    }
  }

  /**
   * Handle and notify if needed when a connection webSocketEvent occurs. For example, when the SDK
   * websocket connection to IBM Aspera App is closed or reconnected.
   *
   * @param webSocketEvent the event type.
   */
  handleWebSocketEvents(webSocketEvent: WebsocketEvent): void {
    if (this.lastWebSocketEvent === webSocketEvent) {
      return;
    }

    this.lastWebSocketEvent = webSocketEvent;

    this.notifyWebSocketEvent(webSocketEvent);
  }

  /**
   * Notify all consumers when a connection webSocketEvent occurs.
   *
   * @param webSocketEvent the event type.
   */
  private notifyWebSocketEvent(webSocketEvent: WebsocketEvent): void {
    if (this.lastNotifiedWebSocketEvent === webSocketEvent) {
      return;
    }

    this.lastNotifiedWebSocketEvent = webSocketEvent;

    this.event_callbacks.forEach(callback => {
      if (typeof callback === 'function') {
        callback(webSocketEvent);
      }
    });
  }

  /** Trigger manual event for other event types. */
  sendManualEventCallback(status: string): void {
    this.event_callbacks.forEach(callback => {
      if (typeof callback === 'function') {
        callback(status);
      }
    });
  }

  /**
   * Notify all consumers when the client changes status. For example, when
   * IBM Aspera App is launched or closed.
   *
   * @param running whether the client is running or not.
   */
  handleClientEvents(running: boolean): void {
    let webSocketEvent: WebsocketEvent;

    if (!running) {
      webSocketEvent = 'CLOSED';
    } else {
      webSocketEvent = this.lastWebSocketEvent;
    }

    this.notifyWebSocketEvent(webSocketEvent);
  }

  /**
   * Notify all consumers when a Safari extension safariExtensionEvent occurs (enabled/disabled).
   *
   * @param safariExtensionEvent the event type.
   */
  handleSafariExtensionEvents(safariExtensionEvent: SafariExtensionEvent): void {
    asperaSdk.SAFARI_EXTENSION_STATUS = safariExtensionEvent;
  }

  /**
   * Set up the activity tracking with IBM Aspera.
   *
   * @returns a promise that resolves when the websocket connection is established.
   * Currently, this promise does not reject.
   */
  setup(): Promise<unknown> {
    if (asperaSdk.globals.sessionId) {
      this.registerDesktopAppSession();
    }

    const finalCall = (): Promise<unknown> => {
      if (isSafari()) {
        return safariClient.monitorTransferActivity();
      }

      return websocketService.init()
        .then(() => {
          websocketService.registerMessage('transfer_activity', (data: ActivityMessage) => this.handleTransferActivity(data));
          websocketService.registerEvent((status: 'CLOSED'|'RECONNECT') => this.handleWebSocketEvents(status));
        });
    };

    if (asperaSdk.globals.supportMultipleUsers) {
      let retryCount = 0;
      const makeVerifyCall = (incrementIt: boolean): Promise<unknown> => {
        if (incrementIt) {
          asperaSdk.globals.rpcPort = asperaSdk.globals.rpcPort + 1;
        }

        if (asperaSdk.globals.rpcPort > 33029) {
          retryCount++;
          asperaSdk.globals.rpcPort = 33024;

          return new Promise(resolve => setTimeout(resolve, retryCount * 1050)).then(() => makeVerifyCall(false));
        }

        return client.request('verify_session', {app_id: asperaSdk.globals.appId, session_id: asperaSdk.globals.sessionId})
          .then(data => {
            if (data.result) {
              return finalCall();
            }

            return makeVerifyCall(true);
          }).catch(() => {
            if (retryCount > 5) {
              asperaSdk.globals.rpcPort = 33024;
              return Promise.reject('Unable to find port running for session');
            }

            return makeVerifyCall(true);
          });
      };

      return makeVerifyCall(false);
    } else {
      return finalCall();
    }
  }

  /**
   * Register a callback for getting transfers back to the consumer
   *
   * @param callback the function to call with the array of transfers
   *
   * @returns the ID of the callback index
   */
  setCallback(callback: (transfers: TransferResponse) => void): string {
    if (typeof callback !== 'function') {
      errorLog(messages.callbackIsNotFunction);
      return;
    }
    const id = `callback-${this.activity_callbacks.size + 1}`;
    this.activity_callbacks.set(id, callback);
    return id;
  }

  /**
   * Remove the callback (deregister) from the list of callbacks
   *
   * @param id the string of the callback to remove
   */
  removeCallback(id: string): void {
    this.activity_callbacks.delete(id);
  }

  /**
   * Register a callback for getting websocket events back to the consumer
   *
   * @param callback the function to call with the websocket event
   *
   * @returns the ID of the callback index
   */
  setWebSocketEventCallback(callback: (status: WebsocketEvent) => void): string {
    if (typeof callback !== 'function') {
      errorLog(messages.callbackIsNotFunction);
      return;
    }
    const id = `callback-${this.event_callbacks.size + 1}`;
    this.event_callbacks.set(id, callback);
    callback(this.lastWebSocketEvent);
    return id;
  }

  /**
   * Remove the callback (deregister) from the list of callbacks
   *
   * @param id the string of the callback to remove
   */
  removeWebSocketEventCallback(id: string): void {
    this.event_callbacks.delete(id);
  }

  private registerDesktopAppSession(): void {
    const iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    iframe.src = `aspera://initialize?app_id=${asperaSdk.globals.appId}&session_id=${asperaSdk.globals.sessionId}`;
    document.body.appendChild(iframe);

    setTimeout(() => {
      document.body.removeChild(iframe);
    }, 1000);
  }
}

export class AsperaSdk {
  /** Global information about IBM Aspera */
  globals: AsperaSdkGlobals = new AsperaSdkGlobals();
  /** Activity tracking for watching transfers */
  /** @ignore */
  activityTracking: ActivityTracking = new ActivityTracking();
  /** HTTP Gateway file store. Key is the file name. */
  httpGatewaySelectedFiles: Map<string, File> = new Map();
  /** Function to initialize IBM Aspera */
  init: (options: InitOptions) => Promise<any>;
  /** Function to test the IBM Aspera status */
  testConnection: () => Promise<any>;
  /** Function to initiate a transfer */
  startTransfer: (transferSpec: TransferSpec, AsperaSdkSpec: AsperaSdkSpec) => Promise<AsperaSdkTransfer>;
  /** Function to launch IBM Aspera */
  launch: () => void;
  /** Register callback for the transfer activity monitor */
  registerActivityCallback: (callback: (transfers: TransferResponse) => void) => string;
  /** Deregister callback to remove it from the callbacks getting transfer data */
  deregisterActivityCallback: (id: string) => void;
  /** Register callback for connection status events from the app */
  registerStatusCallback: (callback: (status: WebsocketEvent) => void) => string;
  /** Deregister callback to remove it from the callbacks getting connection events */
  deregisterStatusCallback: (id: string) => void;
  /** Function to remove a transfer */
  removeTransfer: (transferId: string) => Promise<any>;
  /** Function to show the transfer's download directory in Finder or Windows Explorer */
  showDirectory: (transferId: string) => Promise<any>;
  /** Function to stop a transfer */
  stopTransfer: (transferId: string) => Promise<any>;
  /** Function to resume a transfer */
  resumeTransfer: (transferId: string, options?: ResumeTransferOptions) => Promise<AsperaSdkTransfer>;
  /** Function to get a list of all transfers */
  getAllTransfers: () => Promise<AsperaSdkTransfer[]>;
  /** Function to get information for a specific transfer */
  getTransfer: (transferId: string) => Promise<AsperaSdkTransfer>;
  /** Function to display a file dialog for the user to select files. */
  showSelectFileDialog: (options?: FileDialogOptions) => Promise<DataTransferResponse>;
  /** Function to display a folder dialog for the user to select folders. */
  showSelectFolderDialog: (options?: FolderDialogOptions) => Promise<DataTransferResponse>;
  /** Function to display the IBM Aspera preferences page */
  showPreferences: () => Promise<any>;
  /** Function to modify a running transfer */
  modifyTransfer: (transferId: string, options: ModifyTransferOptions) => Promise<AsperaSdkTransfer>;
  /** Function to set custom branding for IBM Aspera */
  setBranding: (id: string, options: CustomBrandingOptions) => Promise<any>;
  /** Create dropzone for drop events of files */
  createDropzone: (callback: (data: {event: any; files: DataTransferResponse}) => void, elementSelector: string) => void;
  /** Remove dropzone for drop events of files */
  removeDropzone: (elementSelector: string) => void;
  /** Function to get latest installer information */
  getInstallerInfo: (options: InstallerOptions) => Promise<InstallerInfoResponse>;
  /** Initialize drag and drop */
  initDragDrop: () => Promise<any>;
  /** Function to get paginated file-level progress for a transfer */
  getFilesList: (transferId: string, pagination?: Pagination) => Promise<PaginatedFilesResponse>;
  /** Function to get information about the IBM Aspera instance */
  getInfo: () => Promise<AsperaSdkInfo>;
  /** Function to read an entire file as an array buffer (base64-encoded) */
  readAsArrayBuffer: (path: string) => Promise<{data: string; type: string}>;
  /** Function to read a chunk of a file as an array buffer (base64-encoded) */
  readChunkAsArrayBuffer: (path: string, offset: number, chunkSize: number) => Promise<{data: string; type: string}>;
  /** Function to get whether IBM Aspera is running on Safari */
  isSafari: () => boolean;
  /** Function to get URLs for installer management. */
  getInstallerUrls: () => InstallerUrlInfo;
  /** Function to get the SDK capabilities. */
  getCapabilities: () => SdkCapabilities;
  /** Indicate if Safari Extension is enabled. If the extension is disabled during the lifecycle this will not update to disabled. */
  SAFARI_EXTENSION_STATUS: SafariExtensionEvent = 'DISABLED';
  /** Aspera HTTP Gateway calls. This normally is not needed by clients but expose just in case. */
  httpGatewayCalls: unknown;
  /** Store of HTTP Gateway transfers */
  httpGatewayTransferStore: Map<string, AsperaSdkTransfer> = new Map();
  /** HTTP Gateway in app threshold limit. This can be changed globally for the app. */
  httpGatewayInBrowserDownloadThreshold = 1000000000;

  /**
   * Check if IBM Aspera is ready to be used and has been verified.
   *
   * @returns a boolean indicating if SDK can be used for requests
   */
  get isReady(): boolean {
    return this.globals.asperaAppVerified && this.globals.appId !== '';
  }

  /** Indicate that Connect is available. */
  get useConnect(): boolean {
    return this.globals.connectStatus === 'RUNNING';
  }

  /** Indicate that HTTP Gateway is available. */
  get httpGatewayIsReady(): boolean {
    return !!this.globals.httpGatewayVerified;
  }

  /** Indicates if internal calls should use Gateway */
  get useHttpGateway(): boolean {
    return this.httpGatewayIsReady && !this.isReady && !this.useConnect;
  }

  /** Indicates if old HTTP Gateway SDK should be used (v2 and lower) */
  get useOldHttpGateway(): boolean {
    if (!this.useHttpGateway) {
      return false;
    }

    return Number(this.globals.httpGatewayInfo.version.split('.')[0] || 3) <= 2;
  }
}
